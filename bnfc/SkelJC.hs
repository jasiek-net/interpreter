module SkelJC where

-- Haskell module generated by the BNF converter

import AbsJC
import ErrM
type Result = Err String

failure :: Show a => a -> Result
failure x = Bad $ "Undefined case: " ++ show x

transIdent :: Ident -> Result
transIdent x = case x of
  Ident string -> failure x
transProgram :: Program -> Result
transProgram x = case x of
  Pro exps -> failure x
transExp :: Exp -> Result
transExp x = case x of
  EBlock exps -> failure x
  EIfStmt exp1 exp2 -> failure x
  EIfElse exp1 exp2 exp3 -> failure x
  EWhile exp1 exp2 -> failure x
  EForLoo exps exp -> failure x
  EDecEmp ident -> failure x
  EDecVar ident exp -> failure x
  EDecAno idents exp -> failure x
  EDecFun ident idents exp -> failure x
  EFun exp exps -> failure x
  EFunExp exps -> failure x
  EReturn exp -> failure x
  EToStr exp -> failure x
  EToInt exp -> failure x
  EPrint exp -> failure x
  EAss exp1 assop exp2 -> failure x
  EElem ident exp -> failure x
  EPre ssym exp -> failure x
  EPreOp unaop exp -> failure x
  EPost exp ssym -> failure x
  ELor exp1 exp2 -> failure x
  EAnd exp1 exp2 -> failure x
  EEqu exp1 exp2 -> failure x
  ENeq exp1 exp2 -> failure x
  ELrt exp1 exp2 -> failure x
  EGrt exp1 exp2 -> failure x
  EAdd exp1 exp2 -> failure x
  ESub exp1 exp2 -> failure x
  EMul exp1 exp2 -> failure x
  EDiv exp1 exp2 -> failure x
  ENil -> failure x
  EBool boolean -> failure x
  EInt integer -> failure x
  EStr string -> failure x
  EVar ident -> failure x
  EArr exps -> failure x
transSSym :: SSym -> Result
transSSym x = case x of
  SInc -> failure x
  SDec -> failure x
transBoolean :: Boolean -> Result
transBoolean x = case x of
  BTrue -> failure x
  BFalse -> failure x
transAssOp :: AssOp -> Result
transAssOp x = case x of
  ASgn -> failure x
  AMul -> failure x
  ADiv -> failure x
  AAdd -> failure x
  ASub -> failure x
transUnaOp :: UnaOp -> Result
transUnaOp x = case x of
  Poz -> failure x
  Neg -> failure x
  LNe -> failure x

